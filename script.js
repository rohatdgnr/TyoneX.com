const SERVICE_DETAILS = {
  firewall: {
    title: "Firewall (Güvenlik Duvarı)",
    media: {
      src: "https://docs.bissatek.com/images/upload/f6db7ee456682adb988fa2583513d884.jpg",
      alt: "Güvenlik duvarı panosu ve ağ güvenliği konsepti",
    },
    paragraphs: [
      "Şirket bütçenize göre yazılımsal veya donanımsal firewall (güvenlik duvarı) çözümleri sunarak şirketinizi içeriden ve dışarıdan gelecek tehditlere karşı güvence altına alıyoruz.",
      "Personellerinizi yetkilendirerek istediğiniz web siteleri dışında farklı sitelerin açılmasını engelleyerek gereksiz zaman kaybını azaltıyoruz. Personellerinizin log kayıtlarını alarak siz değerli müşterilerimize raporluyor ve aynı zamanda 5651 sayılı kanun gereğini yerine getirmenizi sağlıyoruz."
    ],
  },
  systems: {
    title: "Sistem Kurulum & Destek",
    media: {
      src: "https://www.soder.com.tr/dosyalar/2020/6/services3-50547.png",
      alt: "Sunucu odasında çalışan sistem mühendisi",
    },
    paragraphs: [
      "Şirketinizi daha ileriye taşıyacak sistemlerin ve altyapıların kurulumlarını yaparak BT varlıklarınızın daha güvenilir, daha stabil ve daha hızlı olmasını sağlıyoruz. Ayrıca sistemlerinizin yedekleme süreçleri, iş sürekliliği gereksinimleri ve şirketinizin BT prosedürlerine göre tesis edilip yönetilmesini sağlıyoruz.",
      "İhtiyacınızı tespit ederek sizin için uygun olan sistemleri (Linux & Windows Server ve servisler) kurup yönetiyoruz. Bu şekilde BT maliyetinizi azaltıyor, riskleri kontrol altında tutuyoruz."
    ],
  },
  mssql: {
    title: "MSSQL Çözümleri",
    media: {
      src: "https://keremkus.com/wp-content/uploads/2020/07/MSSQL.jpg",
      alt: "Veritabanı yönetimi ve sunucu rafları",
    },
    paragraphs: [
      "Dünyanın en fazla tercih edilen veritabanlarından biri olan Microsoft SQL Server ortamlarınızda kurulum, bakım, tuning ve yedekleme çözümleri sunuyoruz.",
      "İşletmenizde bulunan muhasebe programlarının (Logo, Mikro vb.) alt yapısında kullanılan veritabanı olan MSSQL Server yönetim hizmetini müşterilerimize veriyoruz. Bunun yanı sıra tuning ve optimizasyon hizmetleri de Tyonex Bilgi Teknolojileri ayrıcalığı ile sunulmaktadır."
    ],
  },
  logo: {
    title: "Logo Çözümlerimiz",
    media: {
      src: "https://kurumsoft.com.tr/wp-content/uploads/2025/04/logo-statu-cozum-gelistirme.png",
      alt: "ERP yazılımı arayüzünü inceleyen ekip",
    },
    paragraphs: [
      "Türkiye’nin önde gelen ERP programı olan Logo Yazılım çözümlerini şirketinizin ihtiyaçlarına göre paket ve modüllerinin satış ve desteğiyle sunuyoruz.",
      "Şirketlerde kullanılan Logo yazılımlarının desteğinin, eğitimlerinin, ilgili raporların alınmasını ve oluşan problemlerin en kısa sürede çözülmesini sağlıyoruz. Üretim modülleri, dış ticaret, Logo Navigator, maliyet sistemleri, özel rapor tasarımları, fatura dizaynları vb. ihtiyaçlarınız için uzman kadromuzla destek veriyor; özel uyarlamalarla olmayan modülleri şirketinize uygun hale getiriyoruz."
    ],
  },
  "logo-flow": {
    title: "Logo Flow",
    media: {
      src: "https://nergabilisim.com/resources/images/Dosya-1653649046509.png",
      alt: "Süreç yönetimi ve iş akışı panosu üzerinde çalışan ekip",
    },
    paragraphs: [
      "İş akışı yönetimi çözümü Logo Flow, işletmelerin kâğıt üzerinde yürüttükleri iş akış uygulamalarını elektronik ortama taşıyarak süreçlerin sorunsuz işlemesini, zaman ve iş gücü tasarrufu elde edilmesini sağlıyor.",
      "Bir işletmenin tüm iş süreçlerini takip eden Logo Flow, sistemin zamanında, planlandığı şekilde ve belirlenen kriterlerde işleyip işlemediğini kontrol ediyor. Böylece süreçler her zaman aynı kalitede yürütülüyor."
    ],
  },
  eflow: {
    title: "E-Flow",
    media: {
      src: "https://tyonex.com.tr/images/eflow.jpg",
      alt: "İş akışı diyagramı ve BPM arayüzü",
    },
    paragraphs: [
      "E-Flow BPM ürünüyle iş akışı ve süreç yönetimi ihtiyaçlarınızı hızlandırıyoruz. Süreçlerinizin dijitalleşmesiyle birlikte işletme içi koordinasyonu güçlendiriyoruz.",
      "E-Flow iş akışı süreç yönetimi özelliğiyle zaman ve maliyet takipleri yapabilirsiniz. İş süreçleri tasarlanırken verimliliği artırır, operasyonel görünürlüğü yükseltir."
    ],
  },
  "custom-software": {
    title: "Özel Yazılım Çözümleri",
    media: {
      src: "https://trioshap.com/uploads/og/ihtiyaca-ozel-yazilim-gelistirme-1200x675.jpg",
      alt: "Yazılım geliştirici ekibi çalışma ortamında",
    },
    paragraphs: [
      "Şirket ihtiyacınıza göre gerek muhasebe programlarınıza gerek ise şirketinizde kullanılmak üzere özel yazılım çözümleri geliştiriyoruz. Uzman kadromuzla proje boyunca yanınızdayız.",
      "C#, Java, C++, C, PHP gibi yazılım dilleriyle şirketinizin ihtiyacına göre özelleştirilmiş çözümler gerçekleştirerek işlerinizi daha az maliyetle, daha hızlı ve daha ölçeklenebilir hale getiriyoruz."
    ],
  },
  "ip-pbx": {
    title: "IP Santral Çözümleri",
    media: {
      src: "https://www.kry.com.tr/wp-content/uploads/2020/05/ip-santral-cozumleri.jpg.webp",
      alt: "IP telefon ve çağrı yönetim sistemi",
    },
    paragraphs: [
      "Günümüzde yaygınlaşmaya başlayan IP PBX santrallerden biri olan Grandstream SIP uç noktalarının tak çalıştır kuruluma sahip yapısıyla şirket içi iletişiminizi modernize ediyoruz.",
      "Kullanıcı lisansı olmadan 500 kullanıcı açabilme, aynı anda 35-45 aktif görüşme sağlayabilme, otomatik yedekleme, harici disk yedekleme, entegre raporlama ve ses kaydı gibi birçok kabiliyete sahiptir. 4 GB bütünleşik hafıza, 5 seviyeli IVR (interaktif sesli yanıt), voice mail, faks desteği ve entegrasyon için API ile ayrıntılı CDR kayıtlarını izleyebilirsiniz."
    ],
  },
  other: {
    title: "Diğer Hizmetlerimiz",
    media: {
      src: "https://www.enginbilgisayar.net.tr/upload/resimler/bilgisayartamiri.jpg",
      alt: "BT destek ekiplerinin yer aldığı teknoloji laboratuvarı",
    },
    paragraphs: [
      "Bilgisayar tamiri, Karel santral, bulut santral çözümleri, bulut ekran çözümleri, kamera alarm sistemleri, kurulum ve bakım hizmetlerini uzman ekibimizle sunuyoruz.",
      "Tyonex Bilgi Teknolojileri olarak müşterilerin BT altyapısında ihtiyaç duyabileceği her türlü sisteme profesyonelce yaklaşarak en uygun çözümleri kaliteli ve uygun fiyat avantajlarıyla sağlıyoruz."
    ],
  },
};

document.addEventListener("DOMContentLoaded", () => {
  const yearEl = document.getElementById("year");
  if (yearEl) {
    yearEl.textContent = new Date().getFullYear();
  }

  const navToggle = document.querySelector(".nav-toggle");
  const nav = document.querySelector(".main-nav");

  if (navToggle && nav) {
    navToggle.addEventListener("click", () => {
      navToggle.classList.toggle("active");
      nav.classList.toggle("active");
      document.body.classList.toggle("nav-open");
    });

    nav.querySelectorAll("a").forEach((link) => {
      link.addEventListener("click", () => {
        navToggle.classList.remove("active");
        nav.classList.remove("active");
        document.body.classList.remove("nav-open");
      });
    });
  }

  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("in-view");
        }
      });
    },
    {
      threshold: 0.2,
    }
  );

  document
    .querySelectorAll(
      ".section, .service-card, .about-copy, .about-media, .step-card, .tech-card, .culture-card, .innovation-content, .lab-content, .cta-inner, .info-card, .contact-form"
    )
    .forEach((el) => {
      observer.observe(el);
    });

  initGlobalFog();
  initHeroScene();
  initNetworkScene();
  initLabScene();
  initMetricsCounter();
  initCustomCursor();
  initServiceModal();
});

function initHeroScene() {
  const canvas = document.getElementById("hero-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 100);
  camera.position.set(0, 0, 6);

  const baseColor = new THREE.Color("#c1121f");
  const accentColor = new THREE.Color("#ff5c6b");

  const particleCount = 420;
  const positions = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);

  for (let i = 0; i < particleCount; i += 1) {
    const radius = 2.6 + Math.random() * 1.4;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);

    const i3 = i * 3;
    positions[i3] = x;
    positions[i3 + 1] = y;
    positions[i3 + 2] = z;

    const color = baseColor.clone().lerp(accentColor, Math.random() * 0.6);
    colors[i3] = color.r;
    colors[i3 + 1] = color.g;
    colors[i3 + 2] = color.b;
  }

  const particleGeometry = new THREE.BufferGeometry();
  particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  particleGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const particleMaterial = new THREE.PointsMaterial({
    size: 0.05,
    vertexColors: true,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    sizeAttenuation: true,
  });

  const particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);

  const haloGeometry = new THREE.BufferGeometry();
  const haloPositions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i += 1) {
    const radius = 3.4 + Math.random() * 1.6;
    const theta = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 2.2;
    const x = Math.cos(theta) * radius;
    const z = Math.sin(theta) * radius;
    const i3 = i * 3;
    haloPositions[i3] = x;
    haloPositions[i3 + 1] = y;
    haloPositions[i3 + 2] = z;
  }
  haloGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(haloPositions, 3)
  );
  const haloMaterial = new THREE.PointsMaterial({
    size: 0.035,
    color: accentColor.clone().offsetHSL(0.02, 0, 0.1),
    transparent: true,
    opacity: 0.45,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const halo = new THREE.Points(haloGeometry, haloMaterial);
  scene.add(halo);

  const coreGeometry = new THREE.IcosahedronGeometry(2.2, 2);
  const coreEdges = new THREE.EdgesGeometry(coreGeometry);
  const coreMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.2,
  });
  const core = new THREE.LineSegments(coreEdges, coreMaterial);
  scene.add(core);

  const bloomGeometry = new THREE.IcosahedronGeometry(1.2, 0);
  const bloomMaterial = new THREE.MeshBasicMaterial({
    color: accentColor,
    transparent: true,
    opacity: 0.08,
    wireframe: false,
  });
  const bloom = new THREE.Mesh(bloomGeometry, bloomMaterial);
  scene.add(bloom);

  const swirlGroup = new THREE.Group();
  scene.add(swirlGroup);

  for (let i = 0; i < 3; i += 1) {
    const curvePoints = [];
    const radius = 0.8 + i * 0.4;
    const turns = 2 + i;
    for (let t = 0; t <= Math.PI * 2 * turns; t += 0.2) {
      const x = Math.cos(t) * radius;
      const y = Math.sin(t) * radius * 0.6;
      const z = Math.sin(t * 0.5) * 1.4;
      curvePoints.push(new THREE.Vector3(x, y, z));
    }
    const curveGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
    const curveMaterial = new THREE.LineBasicMaterial({
      color: accentColor.clone().offsetHSL(0.02 * i, -0.1, 0.05),
      transparent: true,
      opacity: 0.25,
    });
    const line = new THREE.Line(curveGeometry, curveMaterial);
    swirlGroup.add(line);
  }

  const glowGeometry = new THREE.RingGeometry(1.6, 2.2, 64);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: accentColor,
    transparent: true,
    opacity: 0.12,
    side: THREE.DoubleSide,
  });
  const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
  glowRing.rotation.x = Math.PI / 2;
  scene.add(glowRing);

  const target = new THREE.Vector2();
  const pointer = new THREE.Vector2();

  window.addEventListener("pointermove", (event) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
  });

  function resizeRenderer() {
    const { clientWidth, clientHeight } = canvas.parentElement;
    const needsResize =
      canvas.width !== clientWidth || canvas.height !== clientHeight;

    if (needsResize) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  }

  const clock = new THREE.Clock();

  function render() {
    requestAnimationFrame(render);

    resizeRenderer();

    const elapsed = clock.getElapsedTime();
    particles.rotation.y = elapsed * 0.08;
    particles.rotation.x = Math.sin(elapsed * 0.2) * 0.08;

     halo.rotation.y = elapsed * -0.04;
     halo.rotation.z = Math.sin(elapsed * 0.15) * 0.05;

    core.rotation.y = elapsed * 0.1;
    core.rotation.x = elapsed * 0.05;

    bloom.rotation.y = elapsed * 0.12;
    bloom.material.opacity = 0.08 + Math.sin(elapsed * 0.6) * 0.02;

    swirlGroup.rotation.y = elapsed * 0.18;
    swirlGroup.rotation.x = Math.sin(elapsed * 0.25) * 0.09;

    glowRing.rotation.z = elapsed * 0.1;
    glowRing.material.opacity = 0.1 + Math.sin(elapsed * 0.4) * 0.04;

    target.x += (pointer.x * 0.6 - target.x) * 0.05;
    target.y += (pointer.y * -0.6 - target.y) * 0.05;

    camera.position.x = target.x;
    camera.position.y = target.y;
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
  }

  render();
}

function initNetworkScene() {
  const canvas = document.getElementById("network-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
  camera.position.set(0, 0, 18);

  const nodeMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color("#ff6b7d"),
    transparent: true,
    opacity: 0.85,
  });
  const nodeGeometry = new THREE.SphereGeometry(0.24, 16, 16);

  const nodes = [];
  const connections = new THREE.Group();
  scene.add(connections);

  const gridSize = 12;
  for (let i = 0; i < 50; i += 1) {
    const mesh = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
    mesh.position.set(
      (Math.random() - 0.5) * gridSize,
      (Math.random() - 0.5) * (gridSize * 0.6),
      (Math.random() - 0.5) * gridSize
    );
    mesh.material.color.offsetHSL(Math.random() * 0.05, 0, Math.random() * 0.1);
    scene.add(mesh);
    nodes.push(mesh);
  }

  const connectionMaterial = new THREE.LineBasicMaterial({
    color: new THREE.Color("#ffdde3"),
    transparent: true,
    opacity: 0.3,
  });

  for (let i = 0; i < nodes.length; i += 1) {
    for (let j = i + 1; j < nodes.length; j += 1) {
      if (Math.random() > 0.08) continue;
      const geometry = new THREE.BufferGeometry().setFromPoints([
        nodes[i].position,
        nodes[j].position,
      ]);
      const line = new THREE.Line(geometry, connectionMaterial.clone());
      connections.add(line);
    }
  }

  const ringGeometry = new THREE.RingGeometry(6.5, 7, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: "#c1121f",
    transparent: true,
    opacity: 0.15,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.rotation.x = Math.PI / 2;
  scene.add(ring);

  const resizeRenderer = () => {
    const { clientWidth, clientHeight } = canvas.parentElement;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  };

  const clock = new THREE.Clock();

  const renderScene = () => {
    requestAnimationFrame(renderScene);
    resizeRenderer();

    const elapsed = clock.getElapsedTime();

    nodes.forEach((node, index) => {
      const speed = 0.3 + (index % 5) * 0.03;
      node.position.y += Math.sin(elapsed * speed + index) * 0.0025;
      node.position.x += Math.cos(elapsed * speed * 0.9 + index) * 0.0018;
    });

    connections.children.forEach((line) => {
      line.material.opacity = 0.2 + Math.abs(Math.sin(elapsed * 0.6)) * 0.15;
    });

    scene.rotation.y = Math.sin(elapsed * 0.08) * 0.3;
    scene.rotation.x = Math.cos(elapsed * 0.05) * 0.15;

    ring.rotation.z += 0.002;
    ring.material.opacity = 0.12 + Math.sin(elapsed * 0.5) * 0.03;

    renderer.render(scene, camera);
  };

  renderScene();
}

function initGlobalFog() {
  const canvas = document.getElementById("global-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const scene = new THREE.Scene();

  const uniforms = {
    u_time: { value: 0 },
    u_resolution: {
      value: new THREE.Vector2(window.innerWidth, window.innerHeight),
    },
    u_intensity: { value: 0.55 },
  };

  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_intensity;

      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) +
               (c - a) * u.y * (1.0 - u.x) +
               (d - b) * u.x * u.y;
      }

      float fbm(vec2 st) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 0.0;
        mat2 rot = mat2(0.8, -0.6, 0.6, 0.8);
        for (int i = 0; i < 6; i++) {
          value += amplitude * noise(st);
          st = rot * st * 2.2;
          amplitude *= 0.5;
        }
        return value;
      }

      void main() {
        vec2 st = vUv * 3.4;
        float t = u_time * 0.05;
        float n1 = fbm(st + vec2(t, t * 0.6));
        float n2 = fbm(st * 0.6 - vec2(t * 0.8, t * 1.2));
        float n3 = fbm(st * 1.6 + vec2(-t * 0.4, t * 0.9));
        float fog = (n1 * 0.6 + n2 * 0.3 + n3 * 0.1);
        fog = smoothstep(0.25, 0.85, fog);
        float pulse = 0.4 + 0.3 * sin(u_time * 0.3);
        vec3 base = vec3(0.04, 0.01, 0.02);
        vec3 accent = vec3(0.85, 0.12, 0.19);
        vec3 color = mix(base, accent, clamp(fog * (0.6 + pulse), 0.0, 1.0));
        gl_FragColor = vec4(color, fog * u_intensity);
      }
    `,
    transparent: true,
    depthWrite: false,
  });

  const geometry = new THREE.PlaneGeometry(2, 2);
  const plane = new THREE.Mesh(geometry, material);
  scene.add(plane);

  function resizeRenderer() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const needsResize = canvas.width !== width || canvas.height !== height;
    if (needsResize) {
      renderer.setSize(width, height, false);
      uniforms.u_resolution.value.set(width, height);
    }
  }

  window.addEventListener("resize", resizeRenderer);
  resizeRenderer();

  const clock = new THREE.Clock();

  function render() {
    uniforms.u_time.value += clock.getDelta();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  render();
}

function initLabScene() {
  const canvas = document.getElementById("lab-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(0, 0, 9);

  const torusGeometry = new THREE.TorusKnotGeometry(1.8, 0.55, 240, 36);
  const torusMaterial = new THREE.MeshPhongMaterial({
    color: 0xc1121f,
    emissive: 0x32060a,
    shininess: 85,
    specular: 0xffffff,
    transparent: true,
    opacity: 0.92,
  });
  const torus = new THREE.Mesh(torusGeometry, torusMaterial);
  scene.add(torus);

  const wireGeometry = new THREE.TorusGeometry(3.3, 0.04, 32, 200);
  const wireMaterial = new THREE.MeshBasicMaterial({
    color: 0xff758f,
    transparent: true,
    opacity: 0.2,
  });
  const wire = new THREE.Mesh(wireGeometry, wireMaterial);
  wire.rotation.x = Math.PI / 2;
  scene.add(wire);

  const ambient = new THREE.AmbientLight(0xffffff, 0.45);
  scene.add(ambient);

  const pointLight = new THREE.PointLight(0xff7288, 1.2);
  pointLight.position.set(4, 4, 4);
  scene.add(pointLight);

  const backLight = new THREE.PointLight(0x74a9ff, 0.6);
  backLight.position.set(-4, -3, -5);
  scene.add(backLight);

  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 480;
  const positions = new Float32Array(particlesCount * 3);
  for (let i = 0; i < particlesCount; i += 1) {
    const radius = 4 + Math.random() * 3;
    const angle = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 3;
    positions[i * 3] = Math.cos(angle) * radius;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = Math.sin(angle) * radius;
  }
  particlesGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(positions, 3)
  );
  const particlesMaterial = new THREE.PointsMaterial({
    size: 0.06,
    color: 0xff9fb0,
    transparent: true,
    opacity: 0.45,
    depthWrite: false,
  });
  const particles = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particles);

  const target = new THREE.Vector2();
  window.addEventListener("pointermove", (event) => {
    if (event.pointerType !== "mouse") {
      return;
    }
    const rect = canvas.getBoundingClientRect();
    target.x = ((event.clientX - rect.left) / rect.width - 0.5) * 2;
    target.y = ((event.clientY - rect.top) / rect.height - 0.5) * 2;
  });

  const resizeRenderer = () => {
    const { clientWidth, clientHeight } = canvas.parentElement;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  };

  const clock = new THREE.Clock();

  const renderScene = () => {
    requestAnimationFrame(renderScene);
    resizeRenderer();

    const elapsed = clock.getElapsedTime();

    torus.rotation.y = elapsed * 0.3;
    torus.rotation.x = Math.sin(elapsed * 0.35) * 0.4;

    torus.position.x += (target.x * 0.6 - torus.position.x) * 0.04;
    torus.position.y += (target.y * 0.6 - torus.position.y) * 0.04;

    wire.rotation.z += 0.002;
    wire.material.opacity = 0.2 + Math.sin(elapsed * 0.8) * 0.05;

    particles.rotation.y = elapsed * 0.05;
    particles.rotation.z = Math.sin(elapsed * 0.2) * 0.05;

    renderer.render(scene, camera);
  };

  renderScene();
}

function initServiceModal() {
  const modal = document.getElementById("service-modal");
  const cards = document.querySelectorAll(".service-card[data-service]");
  if (!modal || !cards.length) {
    return;
  }

  const titleEl = document.getElementById("service-modal-title");
  const bodyEl = document.getElementById("service-modal-body");
  const closeEls = modal.querySelectorAll("[data-modal-close]");
  let previousFocus = null;

  const closeModal = () => {
    modal.classList.remove("is-open");
    modal.setAttribute("aria-hidden", "true");
    document.body.classList.remove("modal-open");
    if (previousFocus) {
      previousFocus.focus();
      previousFocus = null;
    }
  };

  const openModal = (key, triggerEl) => {
    const detail = SERVICE_DETAILS[key];
    if (!detail) return;

    previousFocus = triggerEl || null;
    titleEl.textContent = detail.title;
    const mediaMarkup = detail.media
      ? `<figure class="service-modal__media"><img src="${detail.media.src}" alt="${detail.media.alt}" loading="lazy" /></figure>`
      : "";
    bodyEl.innerHTML = `${mediaMarkup}${detail.paragraphs
      .map((p) => `<p>${p}</p>`)
      .join("")}`;

    modal.classList.add("is-open");
    modal.setAttribute("aria-hidden", "false");
    document.body.classList.add("modal-open");

    const focusable = modal.querySelector(".service-modal__close");
    if (focusable) {
      focusable.focus();
    }
  };

  cards.forEach((card) => {
    const key = card.dataset.service;
    card.addEventListener("click", () => openModal(key, card));
    card.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        openModal(key, card);
      }
    });
  });

  closeEls.forEach((el) => {
    el.addEventListener("click", closeModal);
  });

  modal.addEventListener("click", (event) => {
    if (event.target.dataset.modalClose !== undefined) {
      closeModal();
    }
  });

  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && modal.classList.contains("is-open")) {
      closeModal();
    }
  });
}

function initMetricsCounter() {
  const metricsWrapper = document.getElementById("hero-metrics");
  if (!metricsWrapper) {
    return;
  }

  const metricValues = metricsWrapper.querySelectorAll(".metric-value");
  if (!metricValues.length) {
    return;
  }

  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  const animateMetric = (element) => {
    const targetValue = Number(element.dataset.target || 0);
    const prefix = element.dataset.prefix || "";
    const suffix = element.dataset.suffix || "";
    const duration = 1600;
    let start = null;

    const step = (timestamp) => {
      if (!start) start = timestamp;
      const progress = Math.min((timestamp - start) / duration, 1);
      const eased = easeOutCubic(progress);
      const current = Math.floor(targetValue * eased);
      element.textContent = `${prefix}${current}${suffix}`;
      if (progress < 1) {
        requestAnimationFrame(step);
      } else {
        element.textContent = `${prefix}${targetValue}${suffix}`;
      }
    };

    requestAnimationFrame(step);
  };

  const observer = new IntersectionObserver(
    (entries, obs) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          metricsWrapper.classList.add("counted");
          metricValues.forEach(animateMetric);
          obs.disconnect();
        }
      });
    },
    { threshold: 0.5 }
  );

  observer.observe(metricsWrapper);
}

function initCustomCursor() {
  const cursor = document.getElementById("custom-cursor");
  if (!cursor || window.matchMedia("(hover: none)").matches) {
    return;
  }

  let rafId;

  const setPosition = (event) => {
    if (event.pointerType && event.pointerType !== "mouse") {
      cursor.classList.add("hide");
      return;
    }
    cursor.classList.add("show");
    cursor.classList.remove("hide");
    const { clientX, clientY } = event;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      cursor.style.left = `${clientX}px`;
      cursor.style.top = `${clientY}px`;
    });
  };

  window.addEventListener("pointermove", setPosition);
  window.addEventListener("pointerleave", () => cursor.classList.add("hide"));
  window.addEventListener("pointerenter", () => cursor.classList.remove("hide"));

  const interactiveSelectors = [
    ".btn",
    ".service-card",
    ".tech-card",
    ".step-card",
    ".culture-card",
    ".hero-metrics li",
    ".contact-form button",
    ".lab-tag",
    ".service-modal__close",
  ];

  interactiveSelectors.forEach((selector) => {
    document.querySelectorAll(selector).forEach((element) => {
      element.addEventListener("pointerenter", (event) => {
        if (event.pointerType && event.pointerType !== "mouse") return;
        cursor.classList.add("active");
      });
      element.addEventListener("pointerleave", () => {
        cursor.classList.remove("active");
      });
    });
  });

  document.addEventListener("pointerdown", (event) => {
    if (event.pointerType && event.pointerType !== "mouse") return;
    cursor.classList.add("active");
  });

  document.addEventListener("pointerup", (event) => {
    if (event.pointerType && event.pointerType !== "mouse") return;
    cursor.classList.remove("active");
  });
}

