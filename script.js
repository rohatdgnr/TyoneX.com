const SERVICE_DETAILS = {
  firewall: {
    title: "Firewall (GÃ¼venlik DuvarÄ±)",
    media: {
      src: "https://docs.bissatek.com/images/upload/f6db7ee456682adb988fa2583513d884.jpg",
      alt: "GÃ¼venlik duvarÄ± panosu ve aÄŸ gÃ¼venliÄŸi konsepti",
    },
    paragraphs: [
      "Åirket bÃ¼tÃ§enize gÃ¶re yazÄ±lÄ±msal veya donanÄ±msal firewall (gÃ¼venlik duvarÄ±) Ã§Ã¶zÃ¼mleri sunarak ÅŸirketinizi iÃ§eriden ve dÄ±ÅŸarÄ±dan gelecek tehditlere karÅŸÄ± gÃ¼vence altÄ±na alÄ±yoruz.",
      "Personellerinizi yetkilendirerek istediÄŸiniz web siteleri dÄ±ÅŸÄ±nda farklÄ± sitelerin aÃ§Ä±lmasÄ±nÄ± engelleyerek gereksiz zaman kaybÄ±nÄ± azaltÄ±yoruz. Personellerinizin log kayÄ±tlarÄ±nÄ± alarak siz deÄŸerli mÃ¼ÅŸterilerimize raporluyor ve aynÄ± zamanda 5651 sayÄ±lÄ± kanun gereÄŸini yerine getirmenizi saÄŸlÄ±yoruz."
    ],
  },
  systems: {
    title: "Sistem Kurulum & Destek",
    media: {
      src: "https://www.soder.com.tr/dosyalar/2020/6/services3-50547.png",
      alt: "Sunucu odasÄ±nda Ã§alÄ±ÅŸan sistem mÃ¼hendisi",
    },
    paragraphs: [
      "Åirketinizi daha ileriye taÅŸÄ±yacak sistemlerin ve altyapÄ±larÄ±n kurulumlarÄ±nÄ± yaparak BT varlÄ±klarÄ±nÄ±zÄ±n daha gÃ¼venilir, daha stabil ve daha hÄ±zlÄ± olmasÄ±nÄ± saÄŸlÄ±yoruz. AyrÄ±ca sistemlerinizin yedekleme sÃ¼reÃ§leri, iÅŸ sÃ¼rekliliÄŸi gereksinimleri ve ÅŸirketinizin BT prosedÃ¼rlerine gÃ¶re tesis edilip yÃ¶netilmesini saÄŸlÄ±yoruz.",
      "Ä°htiyacÄ±nÄ±zÄ± tespit ederek sizin iÃ§in uygun olan sistemleri (Linux & Windows Server ve servisler) kurup yÃ¶netiyoruz. Bu ÅŸekilde BT maliyetinizi azaltÄ±yor, riskleri kontrol altÄ±nda tutuyoruz."
    ],
  },
  mssql: {
    title: "MSSQL Ã‡Ã¶zÃ¼mleri",
    media: {
      src: "https://keremkus.com/wp-content/uploads/2020/07/MSSQL.jpg",
      alt: "VeritabanÄ± yÃ¶netimi ve sunucu raflarÄ±",
    },
    paragraphs: [
      "DÃ¼nyanÄ±n en fazla tercih edilen veritabanlarÄ±ndan biri olan Microsoft SQL Server ortamlarÄ±nÄ±zda kurulum, bakÄ±m, tuning ve yedekleme Ã§Ã¶zÃ¼mleri sunuyoruz.",
      "Ä°ÅŸletmenizde bulunan muhasebe programlarÄ±nÄ±n (Logo, Mikro vb.) alt yapÄ±sÄ±nda kullanÄ±lan veritabanÄ± olan MSSQL Server yÃ¶netim hizmetini mÃ¼ÅŸterilerimize veriyoruz. Bunun yanÄ± sÄ±ra tuning ve optimizasyon hizmetleri de Tyonex Bilgi Teknolojileri ayrÄ±calÄ±ÄŸÄ± ile sunulmaktadÄ±r."
    ],
  },
  logo: {
    title: "Logo Ã‡Ã¶zÃ¼mlerimiz",
    media: {
      src: "https://kurumsoft.com.tr/wp-content/uploads/2025/04/logo-statu-cozum-gelistirme.png",
      alt: "ERP yazÄ±lÄ±mÄ± arayÃ¼zÃ¼nÃ¼ inceleyen ekip",
    },
    paragraphs: [
      "TÃ¼rkiyeâ€™nin Ã¶nde gelen ERP programÄ± olan Logo YazÄ±lÄ±m Ã§Ã¶zÃ¼mlerini ÅŸirketinizin ihtiyaÃ§larÄ±na gÃ¶re paket ve modÃ¼llerinin satÄ±ÅŸ ve desteÄŸiyle sunuyoruz.",
      "Åirketlerde kullanÄ±lan Logo yazÄ±lÄ±mlarÄ±nÄ±n desteÄŸinin, eÄŸitimlerinin, ilgili raporlarÄ±n alÄ±nmasÄ±nÄ± ve oluÅŸan problemlerin en kÄ±sa sÃ¼rede Ã§Ã¶zÃ¼lmesini saÄŸlÄ±yoruz. Ãœretim modÃ¼lleri, dÄ±ÅŸ ticaret, Logo Navigator, maliyet sistemleri, Ã¶zel rapor tasarÄ±mlarÄ±, fatura dizaynlarÄ± vb. ihtiyaÃ§larÄ±nÄ±z iÃ§in uzman kadromuzla destek veriyor; Ã¶zel uyarlamalarla olmayan modÃ¼lleri ÅŸirketinize uygun hale getiriyoruz."
    ],
  },
  "logo-flow": {
    title: "Logo Flow",
    media: {
      src: "https://nergabilisim.com/resources/images/Dosya-1653649046509.png",
      alt: "SÃ¼reÃ§ yÃ¶netimi ve iÅŸ akÄ±ÅŸÄ± panosu Ã¼zerinde Ã§alÄ±ÅŸan ekip",
    },
    paragraphs: [
      "Ä°ÅŸ akÄ±ÅŸÄ± yÃ¶netimi Ã§Ã¶zÃ¼mÃ¼ Logo Flow, iÅŸletmelerin kÃ¢ÄŸÄ±t Ã¼zerinde yÃ¼rÃ¼ttÃ¼kleri iÅŸ akÄ±ÅŸ uygulamalarÄ±nÄ± elektronik ortama taÅŸÄ±yarak sÃ¼reÃ§lerin sorunsuz iÅŸlemesini, zaman ve iÅŸ gÃ¼cÃ¼ tasarrufu elde edilmesini saÄŸlÄ±yor.",
      "Bir iÅŸletmenin tÃ¼m iÅŸ sÃ¼reÃ§lerini takip eden Logo Flow, sistemin zamanÄ±nda, planlandÄ±ÄŸÄ± ÅŸekilde ve belirlenen kriterlerde iÅŸleyip iÅŸlemediÄŸini kontrol ediyor. BÃ¶ylece sÃ¼reÃ§ler her zaman aynÄ± kalitede yÃ¼rÃ¼tÃ¼lÃ¼yor."
    ],
  },
  eflow: {
    title: "E-Flow",
    media: {
      src: "https://tyonex.com.tr/images/eflow.jpg",
      alt: "Ä°ÅŸ akÄ±ÅŸÄ± diyagramÄ± ve BPM arayÃ¼zÃ¼",
    },
    paragraphs: [
      "E-Flow BPM Ã¼rÃ¼nÃ¼yle iÅŸ akÄ±ÅŸÄ± ve sÃ¼reÃ§ yÃ¶netimi ihtiyaÃ§larÄ±nÄ±zÄ± hÄ±zlandÄ±rÄ±yoruz. SÃ¼reÃ§lerinizin dijitalleÅŸmesiyle birlikte iÅŸletme iÃ§i koordinasyonu gÃ¼Ã§lendiriyoruz.",
      "E-Flow iÅŸ akÄ±ÅŸÄ± sÃ¼reÃ§ yÃ¶netimi Ã¶zelliÄŸiyle zaman ve maliyet takipleri yapabilirsiniz. Ä°ÅŸ sÃ¼reÃ§leri tasarlanÄ±rken verimliliÄŸi artÄ±rÄ±r, operasyonel gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼ yÃ¼kseltir."
    ],
  },
  "custom-software": {
    title: "Ã–zel YazÄ±lÄ±m Ã‡Ã¶zÃ¼mleri",
    media: {
      src: "https://trioshap.com/uploads/og/ihtiyaca-ozel-yazilim-gelistirme-1200x675.jpg",
      alt: "YazÄ±lÄ±m geliÅŸtirici ekibi Ã§alÄ±ÅŸma ortamÄ±nda",
    },
    paragraphs: [
      "Åirket ihtiyacÄ±nÄ±za gÃ¶re gerek muhasebe programlarÄ±nÄ±za gerek ise ÅŸirketinizde kullanÄ±lmak Ã¼zere Ã¶zel yazÄ±lÄ±m Ã§Ã¶zÃ¼mleri geliÅŸtiriyoruz. Uzman kadromuzla proje boyunca yanÄ±nÄ±zdayÄ±z.",
      "C#, Java, C++, C, PHP gibi yazÄ±lÄ±m dilleriyle ÅŸirketinizin ihtiyacÄ±na gÃ¶re Ã¶zelleÅŸtirilmiÅŸ Ã§Ã¶zÃ¼mler gerÃ§ekleÅŸtirerek iÅŸlerinizi daha az maliyetle, daha hÄ±zlÄ± ve daha Ã¶lÃ§eklenebilir hale getiriyoruz."
    ],
  },
  "ip-pbx": {
    title: "IP Santral Ã‡Ã¶zÃ¼mleri",
    media: {
      src: "https://www.kry.com.tr/wp-content/uploads/2020/05/ip-santral-cozumleri.jpg.webp",
      alt: "IP telefon ve Ã§aÄŸrÄ± yÃ¶netim sistemi",
    },
    paragraphs: [
      "GÃ¼nÃ¼mÃ¼zde yaygÄ±nlaÅŸmaya baÅŸlayan IP PBX santrallerden biri olan Grandstream SIP uÃ§ noktalarÄ±nÄ±n tak Ã§alÄ±ÅŸtÄ±r kuruluma sahip yapÄ±sÄ±yla ÅŸirket iÃ§i iletiÅŸiminizi modernize ediyoruz.",
      "KullanÄ±cÄ± lisansÄ± olmadan 500 kullanÄ±cÄ± aÃ§abilme, aynÄ± anda 35-45 aktif gÃ¶rÃ¼ÅŸme saÄŸlayabilme, otomatik yedekleme, harici disk yedekleme, entegre raporlama ve ses kaydÄ± gibi birÃ§ok kabiliyete sahiptir. 4 GB bÃ¼tÃ¼nleÅŸik hafÄ±za, 5 seviyeli IVR (interaktif sesli yanÄ±t), voice mail, faks desteÄŸi ve entegrasyon iÃ§in API ile ayrÄ±ntÄ±lÄ± CDR kayÄ±tlarÄ±nÄ± izleyebilirsiniz."
    ],
  },
  other: {
    title: "DiÄŸer Hizmetlerimiz",
    media: {
      src: "https://www.enginbilgisayar.net.tr/upload/resimler/bilgisayartamiri.jpg",
      alt: "BT destek ekiplerinin yer aldÄ±ÄŸÄ± teknoloji laboratuvarÄ±",
    },
    paragraphs: [
      "Bilgisayar tamiri, Karel santral, bulut santral Ã§Ã¶zÃ¼mleri, bulut ekran Ã§Ã¶zÃ¼mleri, kamera alarm sistemleri, kurulum ve bakÄ±m hizmetlerini uzman ekibimizle sunuyoruz.",
      "Tyonex Bilgi Teknolojileri olarak mÃ¼ÅŸterilerin BT altyapÄ±sÄ±nda ihtiyaÃ§ duyabileceÄŸi her tÃ¼rlÃ¼ sisteme profesyonelce yaklaÅŸarak en uygun Ã§Ã¶zÃ¼mleri kaliteli ve uygun fiyat avantajlarÄ±yla saÄŸlÄ±yoruz."
    ],
  },
};

document.addEventListener("DOMContentLoaded", () => {
  const yearEl = document.getElementById("year");
  if (yearEl) {
    yearEl.textContent = new Date().getFullYear();
  }

  const navToggle = document.querySelector(".nav-toggle");
  const nav = document.querySelector(".main-nav");

  if (navToggle && nav) {
    navToggle.addEventListener("click", () => {
      navToggle.classList.toggle("active");
      nav.classList.toggle("active");
      document.body.classList.toggle("nav-open");
    });

    nav.querySelectorAll("a").forEach((link) => {
      link.addEventListener("click", () => {
        navToggle.classList.remove("active");
        nav.classList.remove("active");
        document.body.classList.remove("nav-open");
      });
    });
  }

  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("in-view");
        }
      });
    },
    {
      threshold: 0.2,
    }
  );

  document
    .querySelectorAll(
      ".section, .service-card, .about-copy, .about-media, .step-card, .tech-card, .culture-card, .innovation-content, .lab-content, .cta-inner, .info-card, .contact-map"
    )
    .forEach((el) => {
      observer.observe(el);
    });

  initGlobalFog();
  initHeroScene();
  initNetworkScene();
  initLabScene();
  initMetricsCounter();
  initCustomCursor();
  initServiceModal();
});

function initHeroScene() {
  const canvas = document.getElementById("hero-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(38, 1, 0.1, 100);
  camera.position.set(0, 0, 6);

  const baseColor = new THREE.Color("#c1121f");
  const accentColor = new THREE.Color("#ff5c6b");

  const particleCount = 420;
  const positions = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);

  for (let i = 0; i < particleCount; i += 1) {
    const radius = 2.6 + Math.random() * 1.4;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);

    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);

    const i3 = i * 3;
    positions[i3] = x;
    positions[i3 + 1] = y;
    positions[i3 + 2] = z;

    const color = baseColor.clone().lerp(accentColor, Math.random() * 0.6);
    colors[i3] = color.r;
    colors[i3 + 1] = color.g;
    colors[i3 + 2] = color.b;
  }

  const particleGeometry = new THREE.BufferGeometry();
  particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  particleGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const particleMaterial = new THREE.PointsMaterial({
    size: 0.05,
    vertexColors: true,
    transparent: true,
    opacity: 0.85,
    depthWrite: false,
    sizeAttenuation: true,
  });

  const particles = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particles);

  const haloGeometry = new THREE.BufferGeometry();
  const haloPositions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount; i += 1) {
    const radius = 3.4 + Math.random() * 1.6;
    const theta = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 2.2;
    const x = Math.cos(theta) * radius;
    const z = Math.sin(theta) * radius;
    const i3 = i * 3;
    haloPositions[i3] = x;
    haloPositions[i3 + 1] = y;
    haloPositions[i3 + 2] = z;
  }
  haloGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(haloPositions, 3)
  );
  const haloMaterial = new THREE.PointsMaterial({
    size: 0.035,
    color: accentColor.clone().offsetHSL(0.02, 0, 0.1),
    transparent: true,
    opacity: 0.45,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const halo = new THREE.Points(haloGeometry, haloMaterial);
  scene.add(halo);

  const coreGeometry = new THREE.IcosahedronGeometry(2.2, 2);
  const coreEdges = new THREE.EdgesGeometry(coreGeometry);
  const coreMaterial = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.2,
  });
  const core = new THREE.LineSegments(coreEdges, coreMaterial);
  scene.add(core);

  const bloomGeometry = new THREE.IcosahedronGeometry(1.2, 0);
  const bloomMaterial = new THREE.MeshBasicMaterial({
    color: accentColor,
    transparent: true,
    opacity: 0.08,
    wireframe: false,
  });
  const bloom = new THREE.Mesh(bloomGeometry, bloomMaterial);
  scene.add(bloom);

  const swirlGroup = new THREE.Group();
  scene.add(swirlGroup);

  for (let i = 0; i < 3; i += 1) {
    const curvePoints = [];
    const radius = 0.8 + i * 0.4;
    const turns = 2 + i;
    for (let t = 0; t <= Math.PI * 2 * turns; t += 0.2) {
      const x = Math.cos(t) * radius;
      const y = Math.sin(t) * radius * 0.6;
      const z = Math.sin(t * 0.5) * 1.4;
      curvePoints.push(new THREE.Vector3(x, y, z));
    }
    const curveGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
    const curveMaterial = new THREE.LineBasicMaterial({
      color: accentColor.clone().offsetHSL(0.02 * i, -0.1, 0.05),
      transparent: true,
      opacity: 0.25,
    });
    const line = new THREE.Line(curveGeometry, curveMaterial);
    swirlGroup.add(line);
  }

  const glowGeometry = new THREE.RingGeometry(1.6, 2.2, 64);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: accentColor,
    transparent: true,
    opacity: 0.12,
    side: THREE.DoubleSide,
  });
  const glowRing = new THREE.Mesh(glowGeometry, glowMaterial);
  glowRing.rotation.x = Math.PI / 2;
  scene.add(glowRing);

  const target = new THREE.Vector2();
  const pointer = new THREE.Vector2();

  window.addEventListener("pointermove", (event) => {
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
  });

  function resizeRenderer() {
    const { clientWidth, clientHeight } = canvas.parentElement;
    const needsResize =
      canvas.width !== clientWidth || canvas.height !== clientHeight;

    if (needsResize) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  }

  const clock = new THREE.Clock();

  function render() {
    requestAnimationFrame(render);

    resizeRenderer();

    const elapsed = clock.getElapsedTime();
    particles.rotation.y = elapsed * 0.08;
    particles.rotation.x = Math.sin(elapsed * 0.2) * 0.08;

     halo.rotation.y = elapsed * -0.04;
     halo.rotation.z = Math.sin(elapsed * 0.15) * 0.05;

    core.rotation.y = elapsed * 0.1;
    core.rotation.x = elapsed * 0.05;

    bloom.rotation.y = elapsed * 0.12;
    bloom.material.opacity = 0.08 + Math.sin(elapsed * 0.6) * 0.02;

    swirlGroup.rotation.y = elapsed * 0.18;
    swirlGroup.rotation.x = Math.sin(elapsed * 0.25) * 0.09;

    glowRing.rotation.z = elapsed * 0.1;
    glowRing.material.opacity = 0.1 + Math.sin(elapsed * 0.4) * 0.04;

    target.x += (pointer.x * 0.6 - target.x) * 0.05;
    target.y += (pointer.y * -0.6 - target.y) * 0.05;

    camera.position.x = target.x;
    camera.position.y = target.y;
    camera.lookAt(0, 0, 0);

    renderer.render(scene, camera);
  }

  render();
}

function initNetworkScene() {
  const canvas = document.getElementById("network-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
  camera.position.set(0, 0, 18);

  const nodeMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color("#ff6b7d"),
    transparent: true,
    opacity: 0.85,
  });
  const nodeGeometry = new THREE.SphereGeometry(0.24, 16, 16);

  const nodes = [];
  const connections = new THREE.Group();
  scene.add(connections);

  const gridSize = 12;
  for (let i = 0; i < 50; i += 1) {
    const mesh = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
    mesh.position.set(
      (Math.random() - 0.5) * gridSize,
      (Math.random() - 0.5) * (gridSize * 0.6),
      (Math.random() - 0.5) * gridSize
    );
    mesh.material.color.offsetHSL(Math.random() * 0.05, 0, Math.random() * 0.1);
    scene.add(mesh);
    nodes.push(mesh);
  }

  const connectionMaterial = new THREE.LineBasicMaterial({
    color: new THREE.Color("#ffdde3"),
    transparent: true,
    opacity: 0.3,
  });

  for (let i = 0; i < nodes.length; i += 1) {
    for (let j = i + 1; j < nodes.length; j += 1) {
      if (Math.random() > 0.08) continue;
      const geometry = new THREE.BufferGeometry().setFromPoints([
        nodes[i].position,
        nodes[j].position,
      ]);
      const line = new THREE.Line(geometry, connectionMaterial.clone());
      connections.add(line);
    }
  }

  const ringGeometry = new THREE.RingGeometry(6.5, 7, 64);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: "#c1121f",
    transparent: true,
    opacity: 0.15,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.rotation.x = Math.PI / 2;
  scene.add(ring);

  const resizeRenderer = () => {
    const { clientWidth, clientHeight } = canvas.parentElement;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  };

  const clock = new THREE.Clock();

  const renderScene = () => {
    requestAnimationFrame(renderScene);
    resizeRenderer();

    const elapsed = clock.getElapsedTime();

    nodes.forEach((node, index) => {
      const speed = 0.3 + (index % 5) * 0.03;
      node.position.y += Math.sin(elapsed * speed + index) * 0.0025;
      node.position.x += Math.cos(elapsed * speed * 0.9 + index) * 0.0018;
    });

    connections.children.forEach((line) => {
      line.material.opacity = 0.2 + Math.abs(Math.sin(elapsed * 0.6)) * 0.15;
    });

    scene.rotation.y = Math.sin(elapsed * 0.08) * 0.3;
    scene.rotation.x = Math.cos(elapsed * 0.05) * 0.15;

    ring.rotation.z += 0.002;
    ring.material.opacity = 0.12 + Math.sin(elapsed * 0.5) * 0.03;

    renderer.render(scene, camera);
  };

  renderScene();
}

function initGlobalFog() {
  const canvas = document.getElementById("global-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const scene = new THREE.Scene();

  const uniforms = {
    u_time: { value: 0 },
    u_resolution: {
      value: new THREE.Vector2(window.innerWidth, window.innerHeight),
    },
    u_intensity: { value: 0.55 },
  };

  const material = new THREE.ShaderMaterial({
    uniforms,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_intensity;

      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      float noise(vec2 st) {
        vec2 i = floor(st);
        vec2 f = fract(st);
        float a = random(i);
        float b = random(i + vec2(1.0, 0.0));
        float c = random(i + vec2(0.0, 1.0));
        float d = random(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) +
               (c - a) * u.y * (1.0 - u.x) +
               (d - b) * u.x * u.y;
      }

      float fbm(vec2 st) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 0.0;
        mat2 rot = mat2(0.8, -0.6, 0.6, 0.8);
        for (int i = 0; i < 6; i++) {
          value += amplitude * noise(st);
          st = rot * st * 2.2;
          amplitude *= 0.5;
        }
        return value;
      }

      void main() {
        vec2 st = vUv * 3.4;
        float t = u_time * 0.05;
        float n1 = fbm(st + vec2(t, t * 0.6));
        float n2 = fbm(st * 0.6 - vec2(t * 0.8, t * 1.2));
        float n3 = fbm(st * 1.6 + vec2(-t * 0.4, t * 0.9));
        float fog = (n1 * 0.6 + n2 * 0.3 + n3 * 0.1);
        fog = smoothstep(0.25, 0.85, fog);
        float pulse = 0.4 + 0.3 * sin(u_time * 0.3);
        vec3 base = vec3(0.04, 0.01, 0.02);
        vec3 accent = vec3(0.85, 0.12, 0.19);
        vec3 color = mix(base, accent, clamp(fog * (0.6 + pulse), 0.0, 1.0));
        gl_FragColor = vec4(color, fog * u_intensity);
      }
    `,
    transparent: true,
    depthWrite: false,
  });

  const geometry = new THREE.PlaneGeometry(2, 2);
  const plane = new THREE.Mesh(geometry, material);
  scene.add(plane);

  function resizeRenderer() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const needsResize = canvas.width !== width || canvas.height !== height;
    if (needsResize) {
      renderer.setSize(width, height, false);
      uniforms.u_resolution.value.set(width, height);
    }
  }

  window.addEventListener("resize", resizeRenderer);
  resizeRenderer();

  const clock = new THREE.Clock();

  function render() {
    uniforms.u_time.value += clock.getDelta();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  render();
}

function initLabScene() {
  const canvas = document.getElementById("lab-canvas");
  if (!canvas || !window.THREE) {
    return;
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
    alpha: true,
    antialias: true,
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(0, 0, 9);

  const torusGeometry = new THREE.TorusKnotGeometry(1.8, 0.55, 240, 36);
  const torusMaterial = new THREE.MeshPhongMaterial({
    color: 0xc1121f,
    emissive: 0x32060a,
    shininess: 85,
    specular: 0xffffff,
    transparent: true,
    opacity: 0.92,
  });
  const torus = new THREE.Mesh(torusGeometry, torusMaterial);
  scene.add(torus);

  const wireGeometry = new THREE.TorusGeometry(3.3, 0.04, 32, 200);
  const wireMaterial = new THREE.MeshBasicMaterial({
    color: 0xff758f,
    transparent: true,
    opacity: 0.2,
  });
  const wire = new THREE.Mesh(wireGeometry, wireMaterial);
  wire.rotation.x = Math.PI / 2;
  scene.add(wire);

  const ambient = new THREE.AmbientLight(0xffffff, 0.45);
  scene.add(ambient);

  const pointLight = new THREE.PointLight(0xff7288, 1.2);
  pointLight.position.set(4, 4, 4);
  scene.add(pointLight);

  const backLight = new THREE.PointLight(0x74a9ff, 0.6);
  backLight.position.set(-4, -3, -5);
  scene.add(backLight);

  const particlesGeometry = new THREE.BufferGeometry();
  const particlesCount = 480;
  const positions = new Float32Array(particlesCount * 3);
  for (let i = 0; i < particlesCount; i += 1) {
    const radius = 4 + Math.random() * 3;
    const angle = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 3;
    positions[i * 3] = Math.cos(angle) * radius;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = Math.sin(angle) * radius;
  }
  particlesGeometry.setAttribute(
    "position",
    new THREE.BufferAttribute(positions, 3)
  );
  const particlesMaterial = new THREE.PointsMaterial({
    size: 0.06,
    color: 0xff9fb0,
    transparent: true,
    opacity: 0.45,
    depthWrite: false,
  });
  const particles = new THREE.Points(particlesGeometry, particlesMaterial);
  scene.add(particles);

  const target = new THREE.Vector2();
  window.addEventListener("pointermove", (event) => {
    if (event.pointerType !== "mouse") {
      return;
    }
    const rect = canvas.getBoundingClientRect();
    target.x = ((event.clientX - rect.left) / rect.width - 0.5) * 2;
    target.y = ((event.clientY - rect.top) / rect.height - 0.5) * 2;
  });

  const resizeRenderer = () => {
    const { clientWidth, clientHeight } = canvas.parentElement;
    if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
  };

  const clock = new THREE.Clock();

  const renderScene = () => {
    requestAnimationFrame(renderScene);
    resizeRenderer();

    const elapsed = clock.getElapsedTime();

    torus.rotation.y = elapsed * 0.3;
    torus.rotation.x = Math.sin(elapsed * 0.35) * 0.4;

    torus.position.x += (target.x * 0.6 - torus.position.x) * 0.04;
    torus.position.y += (target.y * 0.6 - torus.position.y) * 0.04;

    wire.rotation.z += 0.002;
    wire.material.opacity = 0.2 + Math.sin(elapsed * 0.8) * 0.05;

    particles.rotation.y = elapsed * 0.05;
    particles.rotation.z = Math.sin(elapsed * 0.2) * 0.05;

    renderer.render(scene, camera);
  };

  renderScene();
}

function initServiceModal() {
  const modal = document.getElementById("service-modal");
  const cards = document.querySelectorAll(".service-card[data-service]");
  if (!modal || !cards.length) {
    return;
  }

  const titleEl = document.getElementById("service-modal-title");
  const bodyEl = document.getElementById("service-modal-body");
  const closeEls = modal.querySelectorAll("[data-modal-close]");
  let previousFocus = null;

  const closeModal = () => {
    modal.classList.remove("is-open");
    modal.setAttribute("aria-hidden", "true");
    document.body.classList.remove("modal-open");
    if (previousFocus) {
      previousFocus.focus();
      previousFocus = null;
    }
  };

  const openModal = (key, triggerEl) => {
    const detail = SERVICE_DETAILS[key];
    if (!detail) return;

    previousFocus = triggerEl || null;
    titleEl.textContent = detail.title;
    const mediaMarkup = detail.media
      ? `<figure class="service-modal__media"><img src="${detail.media.src}" alt="${detail.media.alt}" loading="lazy" /></figure>`
      : "";
    bodyEl.innerHTML = `${mediaMarkup}${detail.paragraphs
      .map((p) => `<p>${p}</p>`)
      .join("")}`;

    modal.classList.add("is-open");
    modal.setAttribute("aria-hidden", "false");
    document.body.classList.add("modal-open");

    const focusable = modal.querySelector(".service-modal__close");
    if (focusable) {
      focusable.focus();
    }
  };

  cards.forEach((card) => {
    const key = card.dataset.service;
    card.addEventListener("click", () => openModal(key, card));
    card.addEventListener("keydown", (event) => {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        openModal(key, card);
      }
    });
  });

  closeEls.forEach((el) => {
    el.addEventListener("click", closeModal);
  });

  modal.addEventListener("click", (event) => {
    if (event.target.dataset.modalClose !== undefined) {
      closeModal();
    }
  });

  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && modal.classList.contains("is-open")) {
      closeModal();
    }
  });
}

function initMetricsCounter() {
  const metricsWrapper = document.getElementById("hero-metrics");
  if (!metricsWrapper) {
    return;
  }

  const metricValues = metricsWrapper.querySelectorAll(".metric-value");
  if (!metricValues.length) {
    return;
  }

  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

  const animateMetric = (element) => {
    const targetValue = Number(element.dataset.target || 0);
    const prefix = element.dataset.prefix || "";
    const suffix = element.dataset.suffix || "";
    const duration = 1600;
    let start = null;

    const step = (timestamp) => {
      if (!start) start = timestamp;
      const progress = Math.min((timestamp - start) / duration, 1);
      const eased = easeOutCubic(progress);
      const current = Math.floor(targetValue * eased);
      element.textContent = `${prefix}${current}${suffix}`;
      if (progress < 1) {
        requestAnimationFrame(step);
      } else {
        element.textContent = `${prefix}${targetValue}${suffix}`;
      }
    };

    requestAnimationFrame(step);
  };

  const observer = new IntersectionObserver(
    (entries, obs) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          metricsWrapper.classList.add("counted");
          metricValues.forEach(animateMetric);
          obs.disconnect();
        }
      });
    },
    { threshold: 0.5 }
  );

  observer.observe(metricsWrapper);
}

function initCustomCursor() {
  const cursor = document.getElementById("custom-cursor");
  if (!cursor || window.matchMedia("(hover: none)").matches) {
    return;
  }

  let rafId;

  const setPosition = (event) => {
    if (event.pointerType && event.pointerType !== "mouse") {
      cursor.classList.add("hide");
      return;
    }
    cursor.classList.add("show");
    cursor.classList.remove("hide");
    const { clientX, clientY } = event;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(() => {
      cursor.style.left = `${clientX}px`;
      cursor.style.top = `${clientY}px`;
    });
  };

  window.addEventListener("pointermove", setPosition);
  window.addEventListener("pointerleave", () => cursor.classList.add("hide"));
  window.addEventListener("pointerenter", () => cursor.classList.remove("hide"));

  const interactiveSelectors = [
    ".btn",
    ".service-card",
    ".tech-card",
    ".step-card",
    ".culture-card",
    ".hero-metrics li",
    ".lab-tag",
    ".service-modal__close",
  ];

  interactiveSelectors.forEach((selector) => {
    document.querySelectorAll(selector).forEach((element) => {
      element.addEventListener("pointerenter", (event) => {
        if (event.pointerType && event.pointerType !== "mouse") return;
        cursor.classList.add("active");
      });
      element.addEventListener("pointerleave", () => {
        cursor.classList.remove("active");
      });
    });
  });

  document.addEventListener("pointerdown", (event) => {
    if (event.pointerType && event.pointerType !== "mouse") return;
    cursor.classList.add("active");
  });

  document.addEventListener("pointerup", (event) => {
    if (event.pointerType && event.pointerType !== "mouse") return;
    cursor.classList.remove("active");
  });
}

document.addEventListener("DOMContentLoaded", () => {
  let percent = 0;
  const percentText = document.getElementById("preloader-percent");
  const barFill = document.getElementById("preloader-bar-fill");

  const loader = setInterval(() => {
    percent += 1;
    percentText.textContent = percent + "%";
    barFill.style.width = percent + "%";

    if (percent >= 100) {
      clearInterval(loader);
      setTimeout(() => {
        document.getElementById("preloader").classList.add("hide");
      }, 300);
    }
  }, 15); // hÄ±z ayarÄ± (15 = hÄ±zlÄ±; 30 = yavaÅŸ)

  initAIChat();
  initNEXAPopups();
});

// AI Chat Widget Functionality
function initAIChat() {
  const chatButton = document.getElementById("ai-chat-button");
  const chatWindow = document.getElementById("ai-chat-window");
  const chatClose = document.getElementById("ai-chat-close");
  const chatInput = document.getElementById("ai-chat-input");
  const chatSend = document.getElementById("ai-chat-send");
  const chatMessages = document.getElementById("ai-chat-messages");
  const quickActions = document.querySelectorAll(".ai-quick-action");

  if (!chatButton || !chatWindow) return;

  // AI Response Generator (Basit kural tabanlÄ± sistem)
  function getAIResponse(userMessage) {
    const message = userMessage.toLowerCase().trim();
    
    // Hizmetler hakkÄ±nda
    if (message.includes("hizmet") || message.includes("ne yapÄ±yorsunuz") || message.includes("hizmetleriniz")) {
      return "Tyonex Bilgi Teknolojileri olarak ÅŸu hizmetleri sunuyoruz:\n\nâ€¢ Firewall (GÃ¼venlik DuvarÄ±) Ã§Ã¶zÃ¼mleri\nâ€¢ Sistem Kurulum & Destek\nâ€¢ MSSQL Ã‡Ã¶zÃ¼mleri\nâ€¢ Logo ERP Ã‡Ã¶zÃ¼mleri\nâ€¢ Logo Flow & E-Flow\nâ€¢ Ã–zel YazÄ±lÄ±m GeliÅŸtirme\nâ€¢ IP Santral Ã‡Ã¶zÃ¼mleri\nâ€¢ Bulut & Yedekleme\n\nDetaylÄ± bilgi iÃ§in hizmetlerimiz bÃ¶lÃ¼mÃ¼ne bakabilirsiniz.";
    }
    
    // Fiyat hakkÄ±nda
    if (message.includes("fiyat") || message.includes("Ã¼cret") || message.includes("maliyet") || message.includes("ne kadar")) {
      return "Hizmetlerimizin fiyatlandÄ±rmasÄ± projenizin kapsamÄ±na ve ihtiyaÃ§larÄ±nÄ±za gÃ¶re deÄŸiÅŸiklik gÃ¶stermektedir. Size Ã¶zel bir teklif hazÄ±rlamak iÃ§in lÃ¼tfen bizimle iletiÅŸime geÃ§in. Telefon: 0216 232 26 98 veya e-posta: info@tyonex.com.tr";
    }
    
    // Ä°letiÅŸim
    if (message.includes("iletiÅŸim") || message.includes("telefon") || message.includes("adres") || message.includes("ulaÅŸ")) {
      return "Bizimle iletiÅŸime geÃ§mek iÃ§in:\n\nğŸ“ Adres: Fatih Mah. YakacÄ±k Cad. No:165/3 Sancaktepe/Ä°stanbul\nğŸ“ Telefon: 0216 232 26 98\nğŸ“§ E-posta: info@tyonex.com.tr\n\nAyrÄ±ca WhatsApp Ã¼zerinden de bize ulaÅŸabilirsiniz!";
    }
    
    // Logo hakkÄ±nda
    if (message.includes("logo") || message.includes("erp")) {
      return "Logo ERP Ã§Ã¶zÃ¼mlerinde uzmanÄ±z. Logo yazÄ±lÄ±mlarÄ±nÄ±n kurulumu, eÄŸitimi, desteÄŸi ve Ã¶zel uyarlamalarÄ±nÄ± yapÄ±yoruz. Logo Flow ve E-Flow iÅŸ akÄ±ÅŸÄ± Ã§Ã¶zÃ¼mlerini de sunuyoruz. DetaylÄ± bilgi iÃ§in hizmetlerimiz bÃ¶lÃ¼mÃ¼ne bakabilirsiniz.";
    }
    
    // YazÄ±lÄ±m hakkÄ±nda
    if (message.includes("yazÄ±lÄ±m") || message.includes("geliÅŸtirme") || message.includes("uygulama")) {
      return "Ã–zel yazÄ±lÄ±m geliÅŸtirme hizmetimizle ihtiyaÃ§larÄ±nÄ±za Ã¶zel web, masaÃ¼stÃ¼ ve mobil uygulamalar geliÅŸtiriyoruz. C#, Java, Python ve modern JavaScript teknolojileri kullanÄ±yoruz. Projeniz iÃ§in detaylÄ± bilgi almak ister misiniz?";
    }
    
    // GÃ¼venlik hakkÄ±nda
    if (message.includes("gÃ¼venlik") || message.includes("firewall") || message.includes("siber")) {
      return "Siber gÃ¼venlik alanÄ±nda firewall Ã§Ã¶zÃ¼mleri, aÄŸ gÃ¼venliÄŸi ve gÃ¼venlik danÄ±ÅŸmanlÄ±ÄŸÄ± hizmetleri sunuyoruz. Åirketinizi iÃ§ ve dÄ±ÅŸ tehditlere karÅŸÄ± koruyoruz. DetaylÄ± bilgi iÃ§in iletiÅŸime geÃ§ebilirsiniz.";
    }
    
    // Genel sorular
    if (message.includes("merhaba") || message.includes("selam") || message.includes("hello") || message.includes("hi")) {
      return "Merhaba! Ben NEXA, Tyonex'in AI asistanÄ±yÄ±m. Size nasÄ±l yardÄ±mcÄ± olabilirim?";
    }
    
    if (message.includes("teÅŸekkÃ¼r") || message.includes("saÄŸol") || message.includes("thanks")) {
      return "Rica ederim! BaÅŸka bir konuda yardÄ±mcÄ± olabilir miyim?";
    }
    
    if (message.includes("nexa") || message.includes("kimsin") || message.includes("sen kimsin")) {
      return "Ben NEXA! Tyonex Bilgi Teknolojileri'nin AI asistanÄ±yÄ±m. Size hizmetlerimiz, fiyatlandÄ±rma ve genel sorularÄ±nÄ±z hakkÄ±nda yardÄ±mcÄ± olmak iÃ§in buradayÄ±m. NasÄ±l yardÄ±mcÄ± olabilirim?";
    }
    
    // VarsayÄ±lan yanÄ±t
    return "AnladÄ±m. Size daha iyi yardÄ±mcÄ± olabilmem iÃ§in lÃ¼tfen sorunuzu biraz daha detaylandÄ±rabilir misiniz? Hizmetlerimiz, fiyatlandÄ±rma veya iletiÅŸim bilgileri hakkÄ±nda bilgi almak isterseniz sÃ¶yleyin.";
  }

  // Mesaj ekleme fonksiyonu
  function addMessage(text, isUser = false) {
    const messageDiv = document.createElement("div");
    messageDiv.className = `ai-message ${isUser ? "ai-message-user" : "ai-message-bot"}`;
    
    const avatar = document.createElement("div");
    avatar.className = "ai-message-avatar nexa-avatar";
    avatar.innerHTML = `<div class="nexa-avatar-inner"><span class="nexa-letter">N</span></div>`;
    
    const content = document.createElement("div");
    content.className = "ai-message-content";
    const paragraphs = text.split("\n\n");
    paragraphs.forEach((para, index) => {
      const p = document.createElement("p");
      p.textContent = para;
      if (index > 0) p.style.marginTop = "0.5rem";
      content.appendChild(p);
    });
    
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(content);
    chatMessages.appendChild(messageDiv);
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  // Mesaj gÃ¶nderme
  function sendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    // KullanÄ±cÄ± mesajÄ±nÄ± ekle
    addMessage(message, true);
    chatInput.value = "";
    
    // AI yanÄ±tÄ±nÄ± simÃ¼le et (kÄ±sa bir gecikme ile)
    setTimeout(() => {
      const response = getAIResponse(message);
      addMessage(response);
    }, 800);
  }

  // Chat aÃ§/kapa
  function toggleChat() {
    const isActive = chatWindow.classList.contains("active");
    if (isActive) {
      chatWindow.classList.remove("active");
      chatWindow.setAttribute("aria-hidden", "true");
    } else {
      chatWindow.classList.add("active");
      chatWindow.setAttribute("aria-hidden", "false");
      chatInput.focus();
    }
  }

  // Event listeners
  chatButton.addEventListener("click", toggleChat);
  chatClose.addEventListener("click", toggleChat);
  chatSend.addEventListener("click", sendMessage);
  
  chatInput.addEventListener("keypress", (e) => {
    if (e.key === "Enter") {
      sendMessage();
    }
  });

  // Quick actions
  quickActions.forEach((action) => {
    action.addEventListener("click", () => {
      const actionType = action.dataset.action;
      let message = "";
      
      switch(actionType) {
        case "hizmetler":
          message = "Hizmetleriniz nelerdir?";
          break;
        case "fiyat":
          message = "FiyatlandÄ±rma hakkÄ±nda bilgi almak istiyorum";
          break;
        case "iletisim":
          message = "Ä°letiÅŸim bilgileriniz nelerdir?";
          break;
      }
      
      if (message) {
        addMessage(message, true);
        setTimeout(() => {
          const response = getAIResponse(message);
          addMessage(response);
        }, 800);
      }
    });
  });

  // DÄ±ÅŸarÄ± tÄ±klandÄ±ÄŸÄ±nda kapat (opsiyonel)
  chatWindow.addEventListener("click", (e) => {
    if (e.target === chatWindow) {
      toggleChat();
    }
  });
}

// NEXA Popup Functionality
function initNEXAPopups() {
  const heroPopup = document.getElementById("nexa-popup-hero");
  const servicesPopup = document.getElementById("nexa-popup-services");
  
  if (!heroPopup || !servicesPopup) return;

  // Popup kapatma fonksiyonu
  function closePopup(popup) {
    popup.classList.remove("show");
  }

  // Popup aÃ§ma fonksiyonu
  function showPopup(popup, delay = 0) {
    setTimeout(() => {
      popup.classList.add("show");
      
      // 8 saniye sonra otomatik kapat
      setTimeout(() => {
        closePopup(popup);
      }, 8000);
    }, delay);
  }

  // Close butonlarÄ±
  heroPopup.querySelector(".nexa-popup-close")?.addEventListener("click", () => {
    closePopup(heroPopup);
  });

  servicesPopup.querySelector(".nexa-popup-close")?.addEventListener("click", () => {
    closePopup(servicesPopup);
  });

  // Hero bÃ¶lÃ¼mÃ¼ gÃ¶rÃ¼nÃ¼r olduÄŸunda popup gÃ¶ster
  const heroSection = document.querySelector(".hero");
  if (heroSection) {
    const heroObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !heroPopup.classList.contains("shown")) {
            showPopup(heroPopup, 2000); // 2 saniye gecikme ile
            heroPopup.classList.add("shown");
            heroObserver.disconnect();
          }
        });
      },
      { threshold: 0.3 }
    );
    heroObserver.observe(heroSection);
  }

  // Services bÃ¶lÃ¼mÃ¼ gÃ¶rÃ¼nÃ¼r olduÄŸunda popup gÃ¶ster
  const servicesSection = document.querySelector("#services");
  if (servicesSection) {
    const servicesObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !servicesPopup.classList.contains("shown")) {
            showPopup(servicesPopup, 1000); // 1 saniye gecikme ile
            servicesPopup.classList.add("shown");
            servicesObserver.disconnect();
          }
        });
      },
      { threshold: 0.3 }
    );
    servicesObserver.observe(servicesSection);
  }

  // Popup'a tÄ±klandÄ±ÄŸÄ±nda chat'i aÃ§
  [heroPopup, servicesPopup].forEach((popup) => {
    popup.addEventListener("click", (e) => {
      if (e.target.closest(".nexa-popup-close")) return;
      const chatButton = document.getElementById("ai-chat-button");
      if (chatButton) {
        chatButton.click();
        closePopup(popup);
      }
    });
  });
}